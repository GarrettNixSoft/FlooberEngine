package com.floober.engine.particles;

import com.floober.engine.particles.behavior.ParticleBehavior;
import com.floober.engine.util.math.MathUtil;
import com.floober.engine.util.math.RandomUtil;
import org.joml.Vector2f;
import org.joml.Vector3f;
import org.joml.Vector4f;

/**
 * Configurable builder for Particle objects.
 */
public class ParticleFactory {

	// particle parameters
	private ParticleTexture particleTexture;
	private final Vector4f particleColor;
	private float particleSizeMin, particleSizeMax;
	private float particleLifeMin, particleLifeMax;
	private float particleSpeedMin, particleSpeedMax;
	private float positionDeltaMin, positionDeltaMax;
	private boolean boxMode;
	private boolean randomColor;

	// particle controls
	private ParticleBehavior particleBehavior;

	public ParticleFactory(ParticleTexture particleTexture, Vector4f particleColor, ParticleBehavior particleBehavior) {
		this.particleTexture = particleTexture;
		this.particleColor = particleColor;
		this.particleBehavior = particleBehavior;
	}

	// INITIALIZERS

	/**
	 * Set initial boundary values for the particle size. This
	 * function ignores greater than or less than checks.
	 * @param particleSizeMin The minimum particle size.
	 * @param particleSizeMax The maximum particle size.
	 */
	public void initSize(float particleSizeMin, float particleSizeMax) {
		this.particleSizeMin = particleSizeMin;
		this.particleSizeMax = particleSizeMax;
	}

	/**
	 * Set initial boundary values for the particle speed. This
	 * function ignores greater than or less than checks.
	 * @param particleSpeedMin The minimum particle speed.
	 * @param particleSpeedMax The maximum particle speed.
	 */
	public void initSpeed(float particleSpeedMin, float particleSpeedMax) {
		this.particleSizeMin = particleSpeedMin;
		this.particleSpeedMax = particleSpeedMax;
	}

	/**
	 * Set initial boundary values for the particle life span. This
	 * function ignores greater than or less than checks.
	 * @param particleLifeMin The minimum particle life span.
	 * @param particleLifeMax The maximum particle life span.
	 */
	public void initLife(float particleLifeMin, float particleLifeMax) {
		this.particleLifeMin = particleLifeMin;
		this.particleLifeMax = particleLifeMax;
	}

	/**
	 * Set initial boundary values for the particle starting position delta.
	 * This function ignores greater than or less than checks.
	 * @param positionDeltaMin The minimum position delta.
	 * @param positionDeltaMax The maximum position delta.
	 */
	public void initPositionDelta(float positionDeltaMin, float positionDeltaMax) {
		this.positionDeltaMin = positionDeltaMin;
		this.positionDeltaMax = positionDeltaMax;
	}

	// GETTERS

	/**
	 * @return The default particle color.
	 */
	public Vector4f getParticleColor() {
		if (randomColor) return new Vector4f(RandomUtil.getFloat(), RandomUtil.getFloat(), RandomUtil.getFloat(), 1);
		else return particleColor;
	}

	/**
	 * @return The texture used by particles generated by this source.
	 */
	public ParticleTexture getParticleTexture() {
		return particleTexture;
	}

	/**
	 * @return Whether random colors is enabled.
	 */
	public boolean isRandomColor() {
		return randomColor;
	}

	/**
	 * @return The minimum particle size, in pixels at the default resolution.
	 */
	public float getParticleSizeMin() {
		return particleSizeMin;
	}

	/**
	 * @return The maximum particle size, in pixels at the default resolution.
	 */
	public float getParticleSizeMax() {
		return particleSizeMax;
	}

	/**
	 * @return The minimum particle life duration, in seconds.
	 */
	public float getParticleLifeMin() {
		return particleLifeMin;
	}

	/**
	 * @return The maximum particle life duration, in seconds.
	 */
	public float getParticleLifeMax() {
		return particleLifeMax;
	}

	/**
	 * @return The minimum particle speed, in pixels per second.
	 */
	public float getParticleSpeedMin() {
		return particleSpeedMin;
	}

	/**
	 * @return The maximum particle speed, in pixels per second.
	 */
	public float getParticleSpeedMax() {
		return particleSpeedMax;
	}

	/**
	 * @return The minimum distance from the source's position that a particle can appear.
	 */
	public float getPositionDeltaMin() {
		return positionDeltaMin;
	}

	/**
	 * @return The maximum distance from the source's position that a particle can appear.
	 */
	public float getPositionDeltaMax() {
		return positionDeltaMax;
	}

	/**
	 * @return Whether box mode is active for particle position ranges. If true, the
	 * position delta values are treated as a box surrounding the source's position.
	 * If false, they are treated as the radius of a circle surrounding the source's
	 * position.
	 */
	public boolean isBoxMode() {
		return boxMode;
	}

	// SETTERS

	/**
	 * Set the texture assigned to particles generated by this source.
	 * @param particleTexture The particle texture.
	 */
	public void setParticleTexture(ParticleTexture particleTexture) {
		this.particleTexture = particleTexture;
	}

	/**
	 * Set whether particles are assigned a random color when created.
	 * When set to false, particles will be given the color assigned to
	 * this ParticleSource.
	 * @param randomColor Whether to enable random colors.
	 */
	public void setRandomColor(boolean randomColor) {
		this.randomColor = randomColor;
	}

	/**
	 * Set the minimum size of particles generated by this source.
	 * If the specified size is smaller than 0, or if it is larger
	 * than the current maximum size, this call is ignored.
	 * @param particleSizeMin The minimum particle size, in pixels at the default resolution.
	 */
	public void setParticleSizeMin(float particleSizeMin) {
		if (particleSizeMin > 0 && particleSizeMin <= particleSizeMax)
			this.particleSizeMin = particleSizeMin;
	}

	/**
	 * Set the maximum size of particles generated by this source.
	 * If the specified size is smaller than the current minimum size,
	 * this call is ignored.
	 * @param particleSizeMax The maximum particle size, in pixels at the default resolution.
	 */
	public void setParticleSizeMax(float particleSizeMax) {
		if (particleSizeMax >= particleSizeMin)
			this.particleSizeMax = particleSizeMax;
	}

	/**
	 * Set the minimum life duration of particles generated by this source.
	 * If the specified duration is shorter than 0, or if it is longer than
	 * the current maximum life duration, this call is ignored.
	 * @param particleLifeMin The minimum particle life span, in seconds.
	 */
	public void setParticleLifeMin(float particleLifeMin) {
		if (particleLifeMin > 0 && particleLifeMin <= particleLifeMax)
			this.particleLifeMin = particleLifeMin;
	}

	/**
	 * Set the maximum life duration of particles generated by this source.
	 * If the specified duration is shorter than the current minimum duration,
	 * this call is ignored.
	 * @param particleLifeMax The maximum particle life duration, in seconds.
	 */
	public void setParticleLifeMax(float particleLifeMax) {
		if (particleLifeMax >= particleLifeMin)
			this.particleLifeMax = particleLifeMax;
	}

	/**
	 * Set the minimum speed of particles generated by this source. The speed
	 * may be zero. If the specified speed is less than 0, or if it is greater
	 * than the current maximum speed, this call is ignored.
	 * @param particleSpeedMin The minimum particle speed, in pixels per second.
	 */
	public void setParticleSpeedMin(float particleSpeedMin) {
		if (particleSpeedMin >= 0 && particleSpeedMin <= particleSpeedMax)
			this.particleSpeedMin = particleSpeedMin;
	}

	/**
	 * Set the maximum speed of particles generated by this source. If the
	 * specified speed is less than the current minimum speed, this call is
	 * ignored.
	 * @param particleSpeedMax The maximum particle speed, in pixels per second.
	 */
	public void setParticleSpeedMax(float particleSpeedMax) {
		if (particleSpeedMax >= particleSpeedMin)
			this.particleSpeedMax = particleSpeedMax;
	}

	/**
	 * Set the minimum distance from the source position that a particle may
	 * appear. If the specified distance is less than zero, or if it is greater
	 * than the current maximum distance, this call is ignored.
	 * @param positionDeltaMin The minimum distance, in pixels at the default resolution.
	 */
	public void setPositionDeltaMin(float positionDeltaMin) {
		if (positionDeltaMin > 0 && positionDeltaMin < positionDeltaMax)
		this.positionDeltaMin = positionDeltaMin;
	}

	/**
	 * Set the maximum distance from the source position that a particle may
	 * appear. If the specified distance is less than the current minimum, this
	 * call is ignored.
	 * @param positionDeltaMax The maximum distance, in pixels at the default resolution.
	 */
	public void setPositionDeltaMax(float positionDeltaMax) {
		if (positionDeltaMax >= positionDeltaMin)
			this.positionDeltaMax = positionDeltaMax;
	}

	/**
	 * Set whether initial position bounds are treated as a bounding square or a circle.
	 * If true, the min/max distances are treated as horizontal and vertical ranges. If
	 * false, the min/max distances are treated as radii at a random angle from the source
	 * position.
	 * @param boxMode Whether to use box mode.
	 */
	public void setBoxMode(boolean boxMode) {
		this.boxMode = boxMode;
	}

	/**
	 * Set the current default color for particles generated by this source.
	 * When random colors are disabled, all particles generated will be
	 * assigned this color.
	 * @param particleColor The default particle color.
	 */
	public void setParticleColor(Vector4f particleColor) {
		this.particleColor.set(particleColor.x(), particleColor.y(), particleColor.z(), particleColor.w());
		randomColor = false;
	}

	public void generateParticle(ParticleBehavior particleBehavior, Vector3f sourcePosition) {
		float speed = RandomUtil.getFloat(particleSpeedMin, particleSpeedMax);
		float angle = RandomUtil.getFloat(360);
		Vector2f velocity = MathUtil.getCartesian(speed, angle);
		float startRotation = RandomUtil.getFloat(360);
		float rotation = 0;
		if (randomColor) {
			float r = RandomUtil.getFloat();
			float g = RandomUtil.getFloat();
			float b = RandomUtil.getFloat();
			particleColor.set(r, g, b);
		}
		float size = RandomUtil.getFloat(particleSizeMin, particleSizeMax);
		float life = RandomUtil.getFloat(particleLifeMin, particleLifeMax);
		// calculate starting position
		Vector3f startingPosition = new Vector3f();
		if (boxMode) {
			float xPos = RandomUtil.getFloat(positionDeltaMin, positionDeltaMax);
			float yPos = RandomUtil.getFloat(positionDeltaMin, positionDeltaMax);
			if (RandomUtil.getBoolean()) xPos = -xPos;
			if (RandomUtil.getBoolean()) yPos = -yPos;
			startingPosition.set(xPos, yPos, 0);
		}
		else {
			float distance = RandomUtil.getFloat(positionDeltaMin, positionDeltaMax);
//			float posAngle = RandomUtil.getFloat(360);
			startingPosition.set(MathUtil.getCartesian(distance, angle), 0); // use the angle of the velocity; this ensures than particles always move away from the center
		}
		// calculate particle position
		Vector3f particlePosition = sourcePosition.add(startingPosition);
		// generate the particle
		new Particle(particleBehavior, particleTexture, particleColor, particlePosition, size, size, velocity, life, startRotation, rotation, true);
	}

}